### 솔리디티 파일 구성

솔리디티 파일은 크게 네 부분으로 구성된다.

1. 프라그마
2. 주석
3. 임포트
4. 계약, 라이브러리, 인터페이스


### 계약

계약을 구성하는 요소는 다음과 같다.

- 상태 변수
- 구조체 정의
- 수정자 정의
- 이벤트 선언
- 열거형 정의
- 함수 정의


### 솔리디티의 느낌 (주관적)

함수 안에 함수를 선언하는 느낌은 자바스크립트의 클로저 같다.
상태 변수를 선언할 때, public, private, protected(?) 등의 스코프를 지정할 수 있는 것은 자바의 느낌이다.
상태 변수를 선언할 때, 영속성, 휘발성 등을 선택할 수 있는 것은 c 게열 or 자바의 느낌이다.
구조체 선언은 c 느낌이다.


### 상태 변수

한정자 종류

- internal : default, 선언함 계약 및 해당 계약이 상속된 계약 안에서의 스코프를 가짐. (외부에서 조회는 가능.)
- private : only 그것을 선언한 계약에서만 사용 가능.
- public : 솔리디티 컴파일러는 public 상태 변수 각각에 대한 getter 함수를 생성한다.
- constant : 상수.

자료형 종류

- bool
- uint, int
- bytes
- address
- mapping
- enum
- struct
- string


### 구조체

계약과 비슷하지만, 구조체는 변수만으로 구성된다. (98년 이전의 c와 비슷한 듯.)


### 수정자

수정자는 http 서버로 볼 때 미들웨어와 비슷한 기능을 수행하는 것 같다.
무언가 함수를 실행하기 이전에 실행되는 전처리 함수이다.


### 이벤트

이벤트는 전역 수준에서 계약과 함께 선언되며 그것의 함수 내에서 호출된다.
이벤트 파라미터에 값을 담아서 보낼 수 있다.
이벤트를 이용하면, 계약의 특정 상태에 변화가 있는지 계속 폴링할 필요가 없다.


### 함수

한정자

1. 함수의 스코프 범위

- public : 외부에서 함수에 직접 접근 가능.
- internal : default, 현재 계약 및 그것을 상속한 계약에서만 사용 가능하다. 외부에서는 이러한 함수들에 접근할 수 없으므로 계약 인터페이스에 속하지 않는다.
- private : 그것을 선언한 계약에서만 사용할 수 있다. 파생 계약에서도 사용할 수 없으며, 계약 인터페이스에 속하지 않는다.
- external : 외부에서 직접적으로 접근할 수 있지만, 내부에서는 접근할 수 없다. 이러한 함수는 계약 인터페이스로 사용된다. (뭐지?)


2. 계약 상태 변수를 변경하는 능력 + 관련한 동작을 바꾸는 능력

- constant : 이 함수는 블록체인의 상태를 수정할 수 없다. 상태 변수를 읽고 호출자에게 반환하는 일은 할 수 있지만, 변수를 수정하거나 이벤트를 호출하거나 다른 계약을 생성하거나 상태를 변경하는 다른 함수를 호출하는 일은 하지 못한다. constant 함수는 현재 상태 변수를 읽고 반환할 수 있는 함수라고 생각하면 된다. (MVC 패턴에서 V만 제공하는 함수 한정자인 듯.)
- view : 뷰 함수는 constant 함수의 별칭이다.
- pure : 순수 함수는 함수의 능력에 제약이 더 많다. 순수 함수는 읽고 쓰지 못한다. 즉 상태 변수에 접근 할 수 없다. 어떤 함수가 현재 상태와 거래 변수에 접근할 수 없게 하려면 순수 함수로 선언하면 된다.
- payable : 함수에 payable 키워드가 붙으면 호출자로부터 이더를 받을 수 있다. 송금자가 이더를 제공하지 않으면 호출이 실패한다. 함수가 payable로 표시되면 이더만 받을 수 있다.


# 자료형

- 값
- 참조

javascript와 비슷한건가, c의 포인터(or c++의 &변수)와 비슷한건가?


솔리디티가 제공하는 값 타입.

- bool
- uint
- int
- address
- byte
- enum


값을 저장하는 것은 메모리의 한 공간을 할당하여 값이 저장된다.
참조는 그 메모리 주소를 저장한다.

이는 c의 포인터와 비슷한 듯 하다. (즉, java가 배열을 저장하거나, javascript가 배열 or 객체 등을 저장하는 방식.)


### 스토리지 및 메모리 데이터 위치

EVM은 변수를 저장하는 용도로 다음 네 가지 데이터 구조를 제공한다.

- 스토리지 : disk와 비슷한 듯. (반영구적 저장.)
- 메모리 : 휘발성
- 호출 데이터 : 모든 입력 함수의 인자와 실행 데이터를 저장하는 곳이다. 이것은 변경할 수 없는 메모리 위치다. (컴퓨터 stack의 data에 해당하는 부분인건가?)
- 스택 : EVM은 변수의 적재와 이더리움 인스트럭션 세트를 가지고 작업하는 중간값을 저장하기 위해 스택을 유지한다. 이것이 EVM의 작업 세트 메모리다. EVM의 스택의 깊이는 1,024단계이며, 그 이상을 저장하면 예외가 발생한다. (overflow 방지인 듯. dfs를 사용할 때 고려하던 것과 비슷한 듯 하다.)


할당 및 데이터 위치는 다음의 규칙으로 설명할 수 있다.

1. 규칙 1

    상태 변수로서 선언되는 변수들은 항상 스토리지 데이터 위치에 저장된다.

2. 규칙 2

    함수 파라미터로서 선언되는 변수들은 항상 메모리 데이터 위치에 저장된다.

3. 규칙 3

    함수 내에서 선언되는 변수들은 기본적으로 메모리 데이터 위치에 저장된다. 그러나 몇 가지 주의할 점이 있다.

        - 참조 타입 변수의 위치는 스토리지가 기본이지만, 값 타입 변수의 위치는 함수 내의 메모리다.
        - 함수 내에서 선언되는 참조 타입 변수의 위치는 스토리지가 기본값이라는 점에 유의하자. 그렇지만 그것은 오버라이드할 수 있다.
        - 참조 타입 변수의 기본 위치를 무시하고 메모리 데이터 위치에 위치시킬 수 있다. 참조형에는 배열, 구조체, 문자열이 있다.
        - 오버라이드 되지 않고, 함수 내에서 선언된 참조형은 항상 상태 변수를 가진다.
        - 함수에서 선언된 값 타입 변수는 오버라이드 되지 못하며, 스토리지 위치에 저장할 수 없다.
        - 매핑은 항상 스토리지 위치에 선언된다. 이는 함수 내에서 선언될 수 없음을 의미한다. 매핑을 메모리형으로 선언할 수는 없지만, 함수 내의 매핑은 상태 변수로 선언된 매핑을 참조할 수 있다.

4. 규칙 4

    호출자가 함수 파라미터에 제공한 인자는 항상 호출 데이터 위치에 저장된다.

5. 규칙 5

    다른 상태 변수로부터 상태 변수에 할당할 때는 항상 새로운 사본을 생성한다. 아래 예에서는 두 개의 값 타입 상태 변수인 stateVar1과 stateVar2를 선언한다. getUInt 함수에서 stateVar2를 stateVar1에 할당한다. 이 단계에서 두 변수의 값은 40이다. 그 다음에 stateVar2의 값을 50으로 변경하고, stateVar1을 반환한다. 반환되는 값은 40으로, 각 변수가 독립적으로 값을 유지함을 알 수 있다.

    (다른 언어들과 비슷하다.)

    ``` solidity
    pragma solidity ^0.4.19;

    contract DemoStorageToStorageValueTypeAssignment {
        uint stateVar1 = 20;
        uint stateVar2 = 40;

        function getUInt() returns (uint) {
            stateVar1 = stateVar2;
            stateVar2 = 50;
            return stateVar1;
        }
    }
    ```

    다음 예에서는 배열 타입 상태 변수 stateArray1과 stateArray2를 선언한다. getUInt 함수에서 stateArray2를 stateArray1에 할당한다. 이 단계에서는 두 변수의 값이 같다. 그 다음 행에서 stateArray2의 값 중 하나를 5로 변경하고 stateArray1 배열에서 같은 위치의 원소를 반환한다. 반환되는 값은 4이므로 각 변수가 독립적인 값을 유지할 수 있다.

    어? 이 부분은 javascript, java, python등의 언어들과 완전히 다르다.

    배열을 그 배열이 시작하는 주소를 저장하여 사용하는 것과는 달리, 솔리디티는 배열 마다 고유의 스토리지 공간을 가지는 것 같다. 이렇게 하면, 퍼포먼스적인 (공간 복잡도)에서는 손해를 보겠지만, 값에 대한 고유성을 가질 수 있는 장점이 있다. 솔리디티 언어의 존재 목적은 결국 원장의 무결적 저장이기 때문에, 퍼포먼스를 조금 잃더라도 그 목적을 더 중요시 여긴 것 같다.

    ``` solidity
    pragma solidity ^0.4.19;

    contract DemoStorageToStorageReferenceTypeAssignment {
        uint[2] stateArray1 = [uint(1), 2];
        uint[2] stateArray2 = [uint(3), 4];

        function getUInt() returns (uint) {
            stateArray1 = stateArray2;
            stateArray2[1] = t;
            return stateArray1[1];  // 4를 반환
        }
    }
    ```

