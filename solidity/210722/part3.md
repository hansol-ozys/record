### 솔리디티 파일 구성

솔리디티 파일은 크게 네 부분으로 구성된다.

1. 프라그마
2. 주석
3. 임포트
4. 계약, 라이브러리, 인터페이스


### 계약

계약을 구성하는 요소는 다음과 같다.

- 상태 변수
- 구조체 정의
- 수정자 정의
- 이벤트 선언
- 열거형 정의
- 함수 정의


### 솔리디티의 느낌 (주관적)

함수 안에 함수를 선언하는 느낌은 자바스크립트의 클로저 같다.
상태 변수를 선언할 때, public, private, protected(?) 등의 스코프를 지정할 수 있는 것은 자바의 느낌이다.
상태 변수를 선언할 때, 영속성, 휘발성 등을 선택할 수 있는 것은 c 게열 or 자바의 느낌이다.
구조체 선언은 c 느낌이다.


### 상태 변수

한정자 종류

- internal : default, 선언함 계약 및 해당 계약이 상속된 계약 안에서의 스코프를 가짐. (외부에서 조회는 가능.)
- private : only 그것을 선언한 계약에서만 사용 가능.
- public : 솔리디티 컴파일러는 public 상태 변수 각각에 대한 getter 함수를 생성한다.
- constant : 상수.

자료형 종류

- bool
- uint, int
- bytes
- address
- mapping
- enum
- struct
- string


### 구조체

계약과 비슷하지만, 구조체는 변수만으로 구성된다. (98년 이전의 c와 비슷한 듯.)


### 수정자

수정자는 http 서버로 볼 때 미들웨어와 비슷한 기능을 수행하는 것 같다.
무언가 함수를 실행하기 이전에 실행되는 전처리 함수이다.


### 이벤트

이벤트는 전역 수준에서 계약과 함께 선언되며 그것의 함수 내에서 호출된다.
이벤트 파라미터에 값을 담아서 보낼 수 있다.
이벤트를 이용하면, 계약의 특정 상태에 변화가 있는지 계속 폴링할 필요가 없다.


### 함수

한정자

1. 함수의 스코프 범위

- public : 외부에서 함수에 직접 접근 가능.
- internal : default, 현재 계약 및 그것을 상속한 계약에서만 사용 가능하다. 외부에서는 이러한 함수들에 접근할 수 없으므로 계약 인터페이스에 속하지 않는다.
- private : 그것을 선언한 계약에서만 사용할 수 있다. 파생 계약에서도 사용할 수 없으며, 계약 인터페이스에 속하지 않는다.
- external : 외부에서 직접적으로 접근할 수 있지만, 내부에서는 접근할 수 없다. 이러한 함수는 계약 인터페이스로 사용된다. (뭐지?)


2. 계약 상태 변수를 변경하는 능력 + 관련한 동작을 바꾸는 능력

- constant : 이 함수는 블록체인의 상태를 수정할 수 없다. 상태 변수를 읽고 호출자에게 반환하는 일은 할 수 있지만, 변수를 수정하거나 이벤트를 호출하거나 다른 계약을 생성하거나 상태를 변경하는 다른 함수를 호출하는 일은 하지 못한다. constant 함수는 현재 상태 변수를 읽고 반환할 수 있는 함수라고 생각하면 된다. (MVC 패턴에서 V만 제공하는 함수 한정자인 듯.)
- view : 뷰 함수는 constant 함수의 별칭이다.
- pure : 순수 함수는 함수의 능력에 제약이 더 많다. 순수 함수는 읽고 쓰지 못한다. 즉 상태 변수에 접근 할 수 없다. 어떤 함수가 현재 상태와 거래 변수에 접근할 수 없게 하려면 순수 함수로 선언하면 된다.
- payable : 함수에 payable 키워드가 붙으면 호출자로부터 이더를 받을 수 있다. 송금자가 이더를 제공하지 않으면 호출이 실패한다. 함수가 payable로 표시되면 이더만 받을 수 있다.


# 자료형

- 값
- 참조

javascript와 비슷한건가, c의 포인터(or c++의 &변수)와 비슷한건가?


솔리디티가 제공하는 값 타입.

- bool
- uint
- int
- address
- byte
- enum


값을 저장하는 것은 메모리의 한 공간을 할당하여 값이 저장된다.
참조는 그 메모리 주소를 저장한다.

이는 c의 포인터와 비슷한 듯 하다. (즉, java가 배열을 저장하거나, javascript가 배열 or 객체 등을 저장하는 방식.)


### 스토리지 및 메모리 데이터 위치

EVM은 변수를 저장하는 용도로 다음 네 가지 데이터 구조를 제공한다.

- 스토리지 : disk와 비슷한 듯. (반영구적 저장.)
- 메모리 : 휘발성
- 호출 데이터 : 모든 입력 함수의 인자와 실행 데이터를 저장하는 곳이다. 이것은 변경할 수 없는 메모리 위치다. (컴퓨터 stack의 data에 해당하는 부분인건가?)
- 스택 : EVM은 변수의 적재와 이더리움 인스트럭션 세트를 가지고 작업하는 중간값을 저장하기 위해 스택을 유지한다. 이것이 EVM의 작업 세트 메모리다. EVM의 스택의 깊이는 1,024단계이며, 그 이상을 저장하면 예외가 발생한다. (overflow 방지인 듯. dfs를 사용할 때 고려하던 것과 비슷한 듯 하다.)