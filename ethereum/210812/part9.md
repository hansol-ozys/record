## 예방 기법

가능하면 send 함수보다는 transfer 함수를 사용하자. 왜냐하면 transfer 함수는 외부 트랜잭션이 실패할 경우 같이 롤백되기 때문이다. send 함수를 써야 한다면 항상 반환 값을 확인해야 한다.

좀 더 강력한 권장사항은 출금 패턴을 채택하는 것이다. 이 솔루션에서 각 사용자는 이더를 컨트랙트로부터 빼내오는 반드시 격리된 함수를 호출해야 하고, 출금 함수가 실패하면 그 결과를 직접 처리해야 한다. 아이디어는 논리적으로 코드 베이스의 나머지 부분으로부터 외부 전송 기능을 격리하고, 최종 사용자가 withdraw 함수를 호출 할 때 잠재적으로 실패한 트랜잭션의 부담을 지게 하는 것이다.

### 실제 사례 : 이더팟과 이더의 왕

이더팟은 복권 추첨 스마트 컨트랙트이고, 앞서 언급한 컨트랙트의 예와 그다지 다르지 않다. 이 컨트랙트의 실패는 주로 블록 해시를 잘못 다용했기 때문에 발생했다. 그러나 이 컨트랙트는 또한 호출 값을 확인하지 않아서 문제가 되기도 했다.

``` solidity
function cash(uint roundIndex, uint subpotIndex) {
    var subpotsCount = getSubpotsCount(roundIndex);

    if (subpotIndex >= subpotsCount) {
        return;
    }

    var decisionBlockNumber = getDecisionBlockNumber(roundIndex, subpotIndex);

    if (decisionBlockNumber > block.number) {
        return;
    }

    if (rounds[roundIndex].isCashed[subpotIndex]) {
        return;
    }

    var winner = calculateWinner(roundIndex, subpotIndex);
    var subpot = getSubpot(roundIndex);

    winner.send(subpot);

    rounds[roundIndex].isCashed[subpotIndex] = true;
}
```

21행에서 send 함수의 반환 값이 확인되지 않고 다음 줄에 승자가 자신의 자금을 보냈다는 것을 나타내는 부울을 설정한다. 이 버그로 인해 우승자가 이더를 받지 못하는 상태가 될 수 있지만, 컨트랙트 상태는 우승자에게 이미 지급된 것으로 나타날 수 있다.

이 버그의 더 심각한 버전이 이더의 왕에서 발생했다. 이 컨트랙트에 대한 훌륭한 분석에는 확인되지 않고 실패한 send 함수가 컨트랙트를 공격하는 데 사용될 수 있는 방법에 대한 세부 정보가 기록되어 있다.

## 레이스 컨디션 / 프런트 러닝

다른 컨트랙트에 대한 외부 호출이 이것이 실행되는 블록체인의 다중 사용자 환경과 결합되면, 잠재적인 여러 솔리디티 함정이 생겨날 수 있다. 그리고 이것은 사용자가 미리 예상하지 못한 상태를 발생시킬 수 있는 코드 실행을 위한 경쟁 상태를 만드는 것이다. 재진입은 그러한 레이스 컨디션의 한 예다. 이번 절에서는 이더리움 블록체인에서 발생할 수 있는 다른 종류의 레이스 컨디션에 대해 설명한다.

### 취약점

대부분의 블록체인과 마찬가지로 이더리움 노드는 트랜잭션을 풀링하여 블록으로 만든다. 채굴자가 합의 메커니즘을 해결하면 트랜잭션은 유효한 것으로 간주한다. 블록을 생성하는 채굴자는 또한 어느 트랜잭션이 블록에 포함될 것인지 풀에서 가스 가격순으로 블록을 정렬하여 선택한다. 여기서 다음과 같은 잠재적인 공격 경로가 생길 수 있다. 공격자는 어떤 문제에 대한 해결책을 포함하는 트랜잭션에 대한 정보를 트랜잭션 풀에서 보고, 해답자의 권한을 수정 또는 취소하거나 트랜잭션상의 상태를 해답자에게 불리하게 바꿀 수 있다. 그런 다음, 공격자는 이 트랜잭션에서 데이터를 가져와서 자신의 트랜잭션을 생성하되, 원본보다 먼저 블록체인에 포함되도록 하기 위해 더 높은 가스 값을 설정할 수 있다.

간단한 예제로 이것이 어떻게 작동하는지 보자.

``` solidity
contract FindThisHash {
    bytes32 constant public hash = 0xb5b5bffweifenbb4bf4343526nfrgggfdsff;

    constructor() public payable {} // 이더 입금

    function solve(string solution) public {
        require(hash == sha3(solution));
        msg.sender.transfer(1000 ether);
    }
}
```

이 컨트랙트에 1,000개의 이더가 들어 있다고 가정해 보자.

SHA-3 해시의 프리이미지를 찾는 사용자는 그 솔루션을 제출하고 1,000개의 이더를 받아올 수 있다. 한 사용자가 솔루션이 Ethereum!이라는 것을 찾아냈다고 가정해 보자. 그들은 Ethereum!을 파라미터로 solve를 호출한다. 유감스럽게도 공격자는 모든 사람이 제출하는 솔루션을 트랜잭션 풀에서 볼 수 있을 정도로 영리하다. 그들은 이 솔루션을 보고 유효성을 확인한 다음, 가스 가격이 원래 트랜잭션보다 훨씬 높은 동일한 트랜잭션을 제출한다. 블록을 만드는 채굴자는 더 높은 가스 가격을 제시하는 공격자의 트랜잭션을 먼저 선택할 것이고, 원래 문제를 해결했던 사람의 트랜잭션보다 먼저 공격자의 트랜잭션을 처리할 것이다. 공격자는 1,000개의 이더를 가져가고 문제를 해결한 사용자는 아무것도 얻을 수 없다. 이러한 '프런트 러닝' 취약점의 경우, 채굴자는 공격 자체를 실행하기 위해 개별적인 인센티브를 받는 것에 유의하자. 공격자가 채굴자가 될 가능성을 과소평가해서는 안 된다.

## 예방 기법

이러한 종류의 프런트 러닝 공격을 수행할 수 있는 액터는 두 가지 클래스가 있다. 사용자와 채굴자다. 첫 번째 클래스에 취약한 컨트랙트는 두 번째 클래스에 취약한 컨트랙트보다 훨씬 나쁘다. 왜냐하면 특정 블록을 대상으로 하는 개별 채굴자와는 다르게, 채굴자는 오직 블록을 채굴할 때 공격을 수행할 수 있기 때문이다. 이러한 두 가지 클래스의 공격을 완화시킬 수 있는 몇 가지 방법을 알아보자.

한 가지 방법은 가스 가격에 상한을 두는 것이다. 이렇게 하면 사용자가 상한 범위 이상으로 gasPrice를 높여서 트랜잭션 우선순위를 갖는 것을 막을 수 있다. 이 방법은 첫 번째 클래스의 공격자만 막는다. 이 시나리오의 채굴자들은 가스 가격과 관계없이 원하는 대로 트랜잭션의 순서를 변경할 수 있기 때문에 컨트랙트를 계속 공격할 수 있다.

좀 더 강력한 방법은 커밋-공개 방식을 사용하는 것이다. 이러한 구조는 사용자가 숨겨진 정보를 사용하여 트랜잭션을 전송하도록 만든다. 트랜잭션이 블록에 포함된 후, 사용자는 전송된 데이터를 표시하는 트랜잭션을 전송한다. 이 방법은 채굴자와 사용자가 트랜잭션의 내용을 결정할 수 없기 때문에 프런트 러닝 트랜잭션을 방지한다. 그러나 이 방법은 트랜잭션 값을 숨길 수 없다. ENS 스마트 컨트랙트를 통해 사용자는 커밋된 데이터에 소비하고자 하는 이더의 양이 포함된 트랜잭션을 보낼 수 있다. 그런 후에 사용자는 임의의 값으로 트랜잭션을 보낼 수 있다. 공개 단계에서 사용자는 트랜잭션에서 보낸 금액과 지출하고자 하는 금액의 차이를 환불받는다.

로렌츠 브레이덴바흐, 필 다이안, 아리 주엘스, 플로리안 트라메르의 제안은 잠수함 송금을 사용하는 것이다. 이 아이디어를 효율적으로 구현하려면 CREATE2 연산코드가 필요하다. 이 연산코드는 현재 채택되지 않았지만, 향후 하드 포크에 포함될 것으로 보인다.

