## 예방 기법

가능하면 send 함수보다는 transfer 함수를 사용하자. 왜냐하면 transfer 함수는 외부 트랜잭션이 실패할 경우 같이 롤백되기 때문이다. send 함수를 써야 한다면 항상 반환 값을 확인해야 한다.

좀 더 강력한 권장사항은 출금 패턴을 채택하는 것이다. 이 솔루션에서 각 사용자는 이더를 컨트랙트로부터 빼내오는 반드시 격리된 함수를 호출해야 하고, 출금 함수가 실패하면 그 결과를 직접 처리해야 한다. 아이디어는 논리적으로 코드 베이스의 나머지 부분으로부터 외부 전송 기능을 격리하고, 최종 사용자가 withdraw 함수를 호출 할 때 잠재적으로 실패한 트랜잭션의 부담을 지게 하는 것이다.

### 실제 사례 : 이더팟과 이더의 왕

이더팟은 복권 추첨 스마트 컨트랙트이고, 앞서 언급한 컨트랙트의 예와 그다지 다르지 않다. 이 컨트랙트의 실패는 주로 블록 해시를 잘못 다용했기 때문에 발생했다. 그러나 이 컨트랙트는 또한 호출 값을 확인하지 않아서 문제가 되기도 했다.

``` solidity
function cash(uint roundIndex, uint subpotIndex) {
    var subpotsCount = getSubpotsCount(roundIndex);

    if (subpotIndex >= subpotsCount) {
        return;
    }

    var decisionBlockNumber = getDecisionBlockNumber(roundIndex, subpotIndex);

    if (decisionBlockNumber > block.number) {
        return;
    }

    if (rounds[roundIndex].isCashed[subpotIndex]) {
        return;
    }

    var winner = calculateWinner(roundIndex, subpotIndex);
    var subpot = getSubpot(roundIndex);

    winner.send(subpot);

    rounds[roundIndex].isCashed[subpotIndex] = true;
}
```

21행에서 send 함수의 반환 값이 확인되지 않고 다음 줄에 승자가 자신의 자금을 보냈다는 것을 나타내는 부울을 설정한다. 이 버그로 인해 우승자가 이더를 받지 못하는 상태가 될 수 있지만, 컨트랙트 상태는 우승자에게 이미 지급된 것으로 나타날 수 있다.

이 버그의 더 심각한 버전이 이더의 왕에서 발생했다. 이 컨트랙트에 대한 훌륭한 분석에는 확인되지 않고 실패한 send 함수가 컨트랙트를 공격하는 데 사용될 수 있는 방법에 대한 세부 정보가 기록되어 있다.

## 레이스 컨디션 / 프런트 러닝

다른 컨트랙트에 대한 외부 호출이 이것이 실행되는 블록체인의 다중 사용자 환경과 결합되면, 잠재적인 여러 솔리디티 함정이 생겨날 수 있다. 그리고 이것은 사용자가 미리 예상하지 못한 상태를 발생시킬 수 있는 코드 실행을 위한 경쟁 상태를 만드는 것이다. 재진입은 그러한 레이스 컨디션의 한 예다. 이번 절에서는 이더리움 블록체인에서 발생할 수 있는 다른 종류의 레이스 컨디션에 대해 설명한다.

### 취약점

대부분의 블록체인과 마찬가지로 이더리움 노드는 트랜잭션을 풀링하여 블록으로 만든다. 채굴자가 합의 메커니즘을 해결하면 트랜잭션은 유효한 것으로 간주한다. 블록을 생성하는 채굴자는 또한 어느 트랜잭션이 블록에 포함될 것인지 풀에서 가스 가격순으로 블록을 정렬하여 선택한다. 여기서 다음과 같은 잠재적인 공격 경로가 생길 수 있다. 공격자는 어떤 문제에 대한 해결책을 포함하는 트랜잭션에 대한 정보를 트랜잭션 풀에서 보고, 해답자의 권한을 수정 또는 취소하거나 트랜잭션상의 상태를 해답자에게 불리하게 바꿀 수 있다. 그런 다음, 공격자는 이 트랜잭션에서 데이터를 가져와서 자신의 트랜잭션을 생성하되, 원본보다 먼저 블록체인에 포함되도록 하기 위해 더 높은 가스 값을 설정할 수 있다.

간단한 예제로 이것이 어떻게 작동하는지 보자.

``` solidity
contract FindThisHash {
    bytes32 constant public hash = 0xb5b5bffweifenbb4bf4343526nfrgggfdsff;

    constructor() public payable {} // 이더 입금

    function solve(string solution) public {
        require(hash == sha3(solution));
        msg.sender.transfer(1000 ether);
    }
}
```

이 컨트랙트에 1,000개의 이더가 들어 있다고 가정해 보자.

SHA-3 해시의 프리이미지를 찾는 사용자는 그 솔루션을 제출하고 1,000개의 이더를 받아올 수 있다. 한 사용자가 솔루션이 Ethereum!이라는 것을 찾아냈다고 가정해 보자. 그들은 Ethereum!을 파라미터로 solve를 호출한다. 유감스럽게도 공격자는 모든 사람이 제출하는 솔루션을 트랜잭션 풀에서 볼 수 있을 정도로 영리하다. 그들은 이 솔루션을 보고 유효성을 확인한 다음, 가스 가격이 원래 트랜잭션보다 훨씬 높은 동일한 트랜잭션을 제출한다. 블록을 만드는 채굴자는 더 높은 가스 가격을 제시하는 공격자의 트랜잭션을 먼저 선택할 것이고, 원래 문제를 해결했던 사람의 트랜잭션보다 먼저 공격자의 트랜잭션을 처리할 것이다. 공격자는 1,000개의 이더를 가져가고 문제를 해결한 사용자는 아무것도 얻을 수 없다. 이러한 '프런트 러닝' 취약점의 경우, 채굴자는 공격 자체를 실행하기 위해 개별적인 인센티브를 받는 것에 유의하자. 공격자가 채굴자가 될 가능성을 과소평가해서는 안 된다.

## 예방 기법

이러한 종류의 프런트 러닝 공격을 수행할 수 있는 액터는 두 가지 클래스가 있다. 사용자와 채굴자다. 첫 번째 클래스에 취약한 컨트랙트는 두 번째 클래스에 취약한 컨트랙트보다 훨씬 나쁘다. 왜냐하면 특정 블록을 대상으로 하는 개별 채굴자와는 다르게, 채굴자는 오직 블록을 채굴할 때 공격을 수행할 수 있기 때문이다. 이러한 두 가지 클래스의 공격을 완화시킬 수 있는 몇 가지 방법을 알아보자.

한 가지 방법은 가스 가격에 상한을 두는 것이다. 이렇게 하면 사용자가 상한 범위 이상으로 gasPrice를 높여서 트랜잭션 우선순위를 갖는 것을 막을 수 있다. 이 방법은 첫 번째 클래스의 공격자만 막는다. 이 시나리오의 채굴자들은 가스 가격과 관계없이 원하는 대로 트랜잭션의 순서를 변경할 수 있기 때문에 컨트랙트를 계속 공격할 수 있다.

좀 더 강력한 방법은 커밋-공개 방식을 사용하는 것이다. 이러한 구조는 사용자가 숨겨진 정보를 사용하여 트랜잭션을 전송하도록 만든다. 트랜잭션이 블록에 포함된 후, 사용자는 전송된 데이터를 표시하는 트랜잭션을 전송한다. 이 방법은 채굴자와 사용자가 트랜잭션의 내용을 결정할 수 없기 때문에 프런트 러닝 트랜잭션을 방지한다. 그러나 이 방법은 트랜잭션 값을 숨길 수 없다. ENS 스마트 컨트랙트를 통해 사용자는 커밋된 데이터에 소비하고자 하는 이더의 양이 포함된 트랜잭션을 보낼 수 있다. 그런 후에 사용자는 임의의 값으로 트랜잭션을 보낼 수 있다. 공개 단계에서 사용자는 트랜잭션에서 보낸 금액과 지출하고자 하는 금액의 차이를 환불받는다.

로렌츠 브레이덴바흐, 필 다이안, 아리 주엘스, 플로리안 트라메르의 제안은 잠수함 송금을 사용하는 것이다. 이 아이디어를 효율적으로 구현하려면 CREATE2 연산코드가 필요하다. 이 연산코드는 현재 채택되지 않았지만, 향후 하드 포크에 포함될 것으로 보인다.

## 실제 사례 : ERC20과 뱅코어

ERC20 표준은 이더리움에서 토큰을 구축하기 위한 것으로 잘 알려져 있다. 이 표준은 approve 기능으로 인해 발생할 수 있는 잠재적인 프런트 러닝 취약점을 갖고 있다. 이 표준은 approve 함수를 다음과 같이 규정한다.

``` solidity
function approve(address _spender, uint256 _value) returns (bool success);
```

이 함수를 사용하면 어떤 한 사용자가 다른 사용자에게 자신을 대신하여 토큰을 전송하는 것을 허용한다. 예를 들어, 취약점은 사ㅛㅇ자 앨리스가 친구인 밥이 100 토큰을 사용하는 것을 승인하는 시나리오에서 발생한다. 앨리스는 나중에 100개의 토큰을 소비하라는 밥에 대한 승인을 철회하기로 결정하여 밥의 할당을 50개의 토큰으로 설정하는 트랜잭션을 만든다. 주의 깊게 체인을 지켜본 밥은 이 트랜잭션을 보고 100개의 토큰을 소비하는 트랜잭션을 작성한다. 그는 앨리스보다 더 높은 가스 가격을 쓴다. 그래서 밥의 트랜잭션은 앨리스의 트랜잭션보다 우선시된다. 어떤 approve의 구현은 앨리스가 트랜잭션을 커밋할 때 밥이 그의 100 토큰을 전송하는 것을 허용하고 밥의 승인을 50토큰으로 다시 설정하여 실제로 밥이 150개의 토큰에 접근할 수 있게 한다.

눈에 띄는 또 다른 실제 사례는 뱅코어다. 그의 팀은 초기 뱅코어 구현에서 수익성 있는 공격을 보여주었다. 그의 블로그 게시물과 데브콘3 토크는 어떻게 이것이 행해졌는지 더 자세하게 논의 했다. 본질적으로 토큰의 가격은 값을 근거로 결정된다. 사용자는 뱅코어 트랜잭션을 위한 트랜잭션 풀을 보고 가격 차이로부터 이익을 얻도록 프런트 러닝할 수 있다. 이 공격은 뱅코어 팀이 이미 해결했다.

## 서비스 거부 (DoS)

이 범주는 매우 광범위하지만, 기본적으로 사용자가 일정 기간 또는 일부의 경우 영구적으로 컨트랙트를 실행할 수 없게 만드는 공격으로 구성된다.

### 취약점

컨트랙트가 동작하지 않게 할 수 있는 방법은 다양하다. 여기서 우리는 DoS 취약점으로 이어질 수 있는 몇 가지 불확실한 솔리디티 코딩 패턴을 강조한다.

- 외부에서 조작된 매핑 또는 배열을 통한 루핑

    이 패턴은 아래의 컨트랙트 사례에서처럼 소유자가 토큰을 distribute 같은 함수로 투자자들에게 분배하기를 원할 때 전형적으로 나타난다.

    ``` solidity
    contract DistributeTokens {
        address public owner;
        address[] investors;
        uint[] investorTokens;

        function invest() public payable {
            investors.psh(msg.sender);
            investorTokens.push(msg.value * 5);
        }

        function distribute() public {
            require(msg.sender == owner)
            for (uint i = 0; i < investors.length; i++) {
                transferToken(investors[i], investorTokens[i]);
            }
        }
    }
    ```

    이 컨트랙트의 루프는 인위적으로 부풀려질 수 있는 배열을 실행한다는 것을 주목하라. 공격자는 많은 사용자 계정을 만들어 investor 배열을 크게 만들 수 있다. 원칙적으로 for 루프를 실행하는 데 요구되는 가스가 블록 가스 한도를 초과하도록 수행할 수 있기 때문에, 근본적으로 distribute 함수가 동작하지 않게 할 수 있다.

- 소유자 운영

    또 다른 공통적인 패턴은 소유자가 컨트랙트에서 특정 권한을 갖고 컨트랙트가 다음 상태로 진행하기 위해 몇 가지 작업을 수행해야 하는 경우다. 일례로, 이니셜 코인 오퍼링 컨트랙트 하나를 들 수 있는데, 이 컨트랙트는 토큰의 송금을 가능하게 하기 위해서 소유자가 컨트랙트를 finalize하도록 요구한다. 예를 들면, 다음과 같다.

    ``` solidity
    bool public isFinalized = false;
    address public owner;

    function finalize() public {
        require(msg.sender == owner);
        isFinalized == true;
    }

    function transfer(address _to, uint _value) returns (bool) {
        require(isFinalized);
        super.transfer(_to, _value);
    }
    ```

    이러한 경우, 권한이 있는 사용자가 개인키를 잃거나 비활성 상태가 되면 전체 토큰 컨트랙트가 작동하지 않는다. 이 경우 소유자가 finalize를 호출할 수 없을 때는 토큰을 전송할 수 없게 되어 전체 토큰 생태계의 운영이 단 하나의 주소에 의해 결정되게 된다.

- 외부 호출을 기반으로 한 진행 상태

    새로운 상태로 진행할 때 주소로 이더를 보내거나 외부 소스로부터 입력을 기다려야 하는 컨트랙트가 종종 작성된다. 이러한 패턴은 외부 호출이 실패하거나 외부적 요인으로 인해 차단된 경우 DoS 공격을 일으킬 수 있다. 이더를 보내야 되는 조건을 가진 예에서는 사용자가 이더의 수신을 허용하지 않는 컨트랙트를 만들 수 있다. 컨트랙트가 새로운 상태로 진행하기 위해 이더가 출금되기를 요구하면, 이 이더는 이더의 수신을 허용하지 않는 사용자의 컨트랙트 때문에 절대 전송될 수 없으므로 컨트랙트는 새로운 상태를 결코 달성하지 못할 것이다.

## 예방 기법

첫 번째 예에서 컨트랙트는 외부 사용자가 인위적으로 조작할 수 있는 데이터 구조를 통해 루프를 돌려서는 안 된다. 각 투자자가 독립적으로 토큰을 청구하기 위해 withdraw 함수를 호출하는 출금 패턴을 추천한다.

두 번째 예는 컨트랙트의 상태를 변경하기 위해 권한 있는 사용자가 필요한 경우였다. 그러한 예에서는 소유자가 무능화되는 경우에 대비한 안전장치가 사용될 수 있다. 한 가지 해결책은 소유자를 다중 컨트랙트로 만드는 것이고, 또 다른 해결책은 시간-잠금을 사용하는 것이다. 주어진 예에서 13행의 require는 require(msg.sender == owner || now > unlockTime)처럼 unlockTime에 의해 지정된 시간 이후에 사용자의 요청이 처리될 수 있는 시간 기반 메커니즘을 포함할 수 있다. 이러한 종류의 완화 기술은 세 번째 예에서도 사용할 수 있다. 만약 새로운 상태로 진행하기 위해 외부 호출이 필요한 경우 호출이 실패할 때 대처할 수 있어야 하고, 요구되는 호출이 결코 일어나지 않은 경우를 대비해 시간 기반의 자동적인 상태 진행이 되도록 하는 장치를 추가해 볼 수도 있다.

### 실제 사례 : GovernMental

GovernMental은 상당히 많은 양의 이더를 축적한 오래된 폰지 스킴이었는데, 유감스럽게도 이 절에서 언급한 DoS 취약점에 취약했다. 이더릭의 레딧 게시물은 컨트랙트에서 이더를 출금하기 위해서 어떻게 매우 큰 매핑을 삭제하도록 그 컨트랙트가 요구했는지를 설명한다. 당시에는 그 매핑을 삭제하는 데 들어가는 가스 비용이 블록가스 한도를 초과했기 때문에 1,100개의 이더를 출금할 수 없었다. 그 컨트랙트의 주소는 0xFEIJFIWEJFEW~~ 이고, 이후 트랜잭션 0x~~~에서 출금할 수 있었다. 이 트랜잭션에서 2.5M 가스를 사용하여 최종적으로 1,100개의 이더를 얻었다.

## 블록 타임스탬프 조작

블록 타임스탬프는 역사적으로 임의의 숫자를 위한 엔트로피, 일정 기간의 자금 잠금 그리고 시간에 의존적인 다양한 상태 변화 조건문 같은 다양한 애플리케이션에 사용되었다. 채굴자는 타임스탬프를 약간 조정할 수 있는데, 이 때문에 스마트 컨트랙트에서 블록 타임스탬프를 잘못 사용하면 위험할 수 있다.

### 취약점

만약 조작할 인센티브가 있다면 채굴자가 block.Timestamp와 그 별칭인 now를 조작할 수 있다. 예제 9-11에서 볼 수 있듯이 간단한 컨트랙트를 만들어보자. 이 컨트랙트는 채굴자의 부당 이용에 취약할 수 있다.

``` solidity
contract Roulette {
    uint public pastBlockTime;

    constructor () public payable {}

    function () public payable {
        require(msg.value == 10 ether);
        require(now != pastBlockTime);
        pastBlockTime = now;
        if (now % 15 == 0) {
            msg.sender.transfer(this.balance);
        }
    }
}
```

이 컨트랙트는 간단한 복권처럼 동작한다. 오직 블록당 한 개의 트랜잭션은 컨트랙트의 전체 밸런스를 받을 수 있는 기회를 얻기 위해 10이더를 걸 수 있다. 여기서 가정은 block.timestamp의 마지막 두 자리가 균등하게 분포되어 있다는 것이다. 그렇다면 이 복권 추첨에 1/15의 기회가 주어진다.

그러나 우리가 알고 있듯이 채굴자는 필요한 경우 타임스탬프를 조정할 수 있다. 위의 케이스에서 만일 컨트랙트에 충분한 이더가 모였다면, 블록을 푸는 채굴자는 block.timestamp 혹은 now 모듈로 15가 0인 타임스탬프를 선택하도록 하는 동기부여가 주어진다. 그렇게 함으로써 그들은 블록 보상과 함께 이 컨트랙트에 잠긴 이더를 얻을 수 있다. 블록당 베팅할 수 있는 사람은 단 한 명이기 때문에 이것은 또한 프런트 러닝 공격에 취약하다.

## 예방 기법

블록 타임스탬프는 엔트로피 또는 랜덤 값을 생성하는 데 사용하면 안 된다. 즉, 게임에서 우승하거나 중요한 상태를 변경하는 데 있어 결정력이 있는 요소가 되어서는 안 된다.

시간에 민감한 논리가 필요한 경우가 있다. 예를 들어, 컨트랙트 해지, 몇 주 후에 ICO 완료 또는 만기일 적용 등이다. 때로는 block.number와 평균 블록 시간을 사용하여 시간을 추정하는 것이 좋다. 10초당 하나의 블록이 생성되고 일주일이면 대략 60480 블록이 된다. 따라서 컨트랙트 상태를 변경할 블록 번호를 특정하는 편이 좀 더 안전할 수 있는데, 채굴자들이 블록 번호를 쉽게 조작할 수 없기 때문이다.

컨트랙트가 특히 블록 타임스탬프의 채굴자 조작과 관련이 없다면 불필요할 수 있지만, 컨트랙트를 개발할 때 주의해야 할 사항이다.

### 실제 사례 : GovernMental

위에서 언급한 오래된 폰지 스킴 역시 타임스탬프 기반 공격에 취약했다. 컨트랙트는 한 라운드에서 마지막으로 참여한 플레이어에게 지급되었다. 따라서 플레이어였던 채굴자가 타임스탬프를 조정하여 그가 최근 1분 동안 참가한 마지막 플레이어인 것처럼 보일 수 있다.

## 생성자 관리

생성자는 컨트랙트를 초기화할 때 종종 중요하고 권한을 필요로 하는 작업을 수행하는 특수 함수다. 솔리디티 v0.4.22 이전에는 생성자가 포함된 컨트랙트와 이름이 같은 함수로 생성자로 정의되었다. 이러한 경우 개발 시 컨트랙트 이름이 변경됐을 때 생성자 이름도 변경되지 않으면 정상적인 호출이 가능한 일반 함수가 된다. 상상할 수 있듯이, 이것은 흥미로운 컨트랙트 해킹을 유도할 수 있다.

### 취약점

컨트랙트 이름이 수정되거나 컨트랙트 이름과 일치하지 않는 생성자 이름에 오타가 있는 경우 생성자는 일반 함수처럼 작동한다. 이는 특히 생성자가 특권이 있는 작업을 수행하는 경우 무서운 결과를 초래할 수 있다.

``` contract OwnerWallet {
    address public owner;

    function ownerWallet(address _owner) public {
        owner = _owner;
    }

    function () payable {}

    function withdraw() public {
        require(msg.sender == owner);
        msg.sender.transfer(this.balance);
    }
}
```

이 컨트랙트는 이더를 수집하고 withdraw 함수를 호출하여 소유자만 철회하도록 허용한다. 생성자의 이름이 컨트랙트와 정확히 동일하지 않기 때문에 문제가 발생한다. 첫 글자가 다르다. 따라서 모든 사용자는 ownerWallet 함수를 호출하여 소유자로 설정한 후에 withdraw를 호출하여 컨트랙트의 모든 이더를 가져올 수 있다.

### 예방 기법

이 문제는 솔리디티 컴파일러 버전 0.4.22에서 해결했다 이 버전은 컨트랙트 이름과 일치하는 함수 이름 대신에 생성자를 지정하는 constructor 키워드를 도입했다. 이름 지정 이슈를 방지하기 위해 이 키워드의 사용을 추천한다.

### 실제 사례 : 루비시

루비시는 이러한 종류의 취약점을 보여주는 또 다른 피라미드 방식이다. 원래 DynamicPyramid라고 했지만, 배포하기 전에 Rubixi로 컨트랙트 이름이 바뀌었다. 생성자의 이름은 변경되지 않았기에 아무나 컨트랙트 소유자가 될 수 있었다. 결국에는 사용자들이 이 피라미드 스킴에서 나오는 수수료를 클레임할 수 있는 소유자 지위를 확보하기 위한 경쟁 상황을 만들었다.

## 초기화되지 않은 스토리지 포인터

EVM은 데이터를 스토리지 혹은 메모리에 저장한다. 컨트랙트 개발 시 함수의 지역 변수에 대한 기본 유형을 정확히 이해하는 것이 좋다. 변수를 부적절하게 초기화하여 취약한 컨트랙트를 생성할 수 있기 때문이다.

EVM에서 스토리지 및 메모리에 대한 자세한 내용은 솔리디티 문서의 데이터 위치, 스토리지의 상태 변수 레이아웃 및 메모리 레이아웃을 참고하라.

### 취약점

함수 내의 지역 변수는 그 타입에 따라 스토리지 또는 메모리를 기본으로 사용한다. 초기화되지 않은 로컬 스토리지 변수에는 컨트랙트의 다른 스토리지 변숫값이 포함될 수 있다. 이러한 사실은 의도하지 않은 취약점을 유발하거나 의도적으로 악용될 수 있다.

``` solidity
contract NameRegistrar {
    bool public unlocked = false;

    struct NameRecord {
        bytes32 name;
        address mappedAddress;
    }

    mapping(address => NameRecord) public registerNameRecord;
    mapping(bytes32 => address) public resolve;

    function register(bytes32 _name, address _mappedAddress) public {
        NameRecord newRecord;
        newRecord.name = _name;
        newRecord.mappedAddress = _mappedAddress;
        resolve[_name] = _mappedAddress;
        registeredNameRecord[msg.sender] = newRecord;

        require(unlocked);
    }
}
```

이 간단한 이름 등록기는 하나의 기능만 갖고 있다. 컨트랙트의 잠금이 해제되면 누구나 이름을 등록하고 해당 이름을 주소에 매핑할 수 있다. 등록자는 초기에 잠겨 있으며, 25행의 require 함수는 register가 이름 레코드를 추가하지 못하도록 한다. 레지스트리를 잠금 해제할 방법이 없으므로 컨트랙트를 사용할 수 없는 것으로 보인다. 그러나 unlocked 변수에 관계없이 이름 등록을 허용하는 취약점이 있다.

이 취약점에 대해 논의하려면 우선 솔리디티에서 스토리지가 어떻게 작동하는지 이해해야 한다. 개략적으로 상태 변수는 컨트랙트에서 나타나는 대로 슬롯에 순차적으로 저장된다. 따라서 slot[0]에 unlocked, slot[1]에 registeredNameRecord, slot[2]에 resolve 등이 존재한다. 각 슬롯의 크기는 32바이트다. 부울 unlocked는 false의 0x0000...0 또는 true 의 0x000...1처럼 보인다. 보다시피 이 특별한 예에서는 상당한 스토리지 낭비가 있다.

다음 퍼즐 조각은 기본적으로 솔리디티가 struct 같은 복잡한 데이터 타입을 지역 변수로 초기화할 때 스토리지에 저장한다는 것이다. 따라서 18행의 newRecord는 기본적으로 스토리지에 저장된다. 취약점은 newRecord가 초기화되지 않았기 때문에 발생한다. 왜냐하면 newRecord는 기본값이 스토리지이고 그것은 스토리지 slot[0]에 매핑되기 때문이다. 19행과 20행에서 newRecord.name을 _name으로 설정하고 newRecord.mappedAddress를 _mappedAddress로 설정한다. 이것은 slot[0] 및 slot[1]의 저장 위치를 갱신하며, 이는 unlocked와 registeredNameRecord 관련 저장 슬롯을 모두 수정한다.