## 예방 기법

가능하면 send 함수보다는 transfer 함수를 사용하자. 왜냐하면 transfer 함수는 외부 트랜잭션이 실패할 경우 같이 롤백되기 때문이다. send 함수를 써야 한다면 항상 반환 값을 확인해야 한다.

좀 더 강력한 권장사항은 출금 패턴을 채택하는 것이다. 이 솔루션에서 각 사용자는 이더를 컨트랙트로부터 빼내오는 반드시 격리된 함수를 호출해야 하고, 출금 함수가 실패하면 그 결과를 직접 처리해야 한다. 아이디어는 논리적으로 코드 베이스의 나머지 부분으로부터 외부 전송 기능을 격리하고, 최종 사용자가 withdraw 함수를 호출 할 때 잠재적으로 실패한 트랜잭션의 부담을 지게 하는 것이다.

### 실제 사례 : 이더팟과 이더의 왕

이더팟은 복권 추첨 스마트 컨트랙트이고, 앞서 언급한 컨트랙트의 예와 그다지 다르지 않다. 이 컨트랙트의 실패는 주로 블록 해시를 잘못 다용했기 때문에 발생했다. 그러나 이 컨트랙트는 또한 호출 값을 확인하지 않아서 문제가 되기도 했다.

``` solidity
function cash(uint roundIndex, uint subpotIndex) {
    var subpotsCount = getSubpotsCount(roundIndex);

    if (subpotIndex >= subpotsCount) {
        return;
    }

    var decisionBlockNumber = getDecisionBlockNumber(roundIndex, subpotIndex);

    if (decisionBlockNumber > block.number) {
        return;
    }

    if (rounds[roundIndex].isCashed[subpotIndex]) {
        return;
    }

    var winner = calculateWinner(roundIndex, subpotIndex);
    var subpot = getSubpot(roundIndex);

    winner.send(subpot);

    rounds[roundIndex].isCashed[subpotIndex] = true;
}
```

21행에서 send 함수의 반환 값이 확인되지 않고 다음 줄에 승자가 자신의 자금을 보냈다는 것을 나타내는 부울을 설정한다. 이 버그로 인해 우승자가 이더를 받지 못하는 상태가 될 수 있지만, 컨트랙트 상태는 우승자에게 이미 지급된 것으로 나타날 수 있다.

이 버그의 더 심각한 버전이 이더의 왕에서 발생했다. 이 컨트랙트에 대한 훌륭한 분석에는 확인되지 않고 실패한 send 함수가 컨트랙트를 공격하는 데 사용될 수 있는 방법에 대한 세부 정보가 기록되어 있다.

## 레이스 컨디션 / 프런트 러닝

다른 컨트랙트에 대한 외부 호출이 이것이 실행되는 블록체인의 다중 사용자 환경과 결합되면, 잠재적인 여러 솔리디티 함정이 생겨날 수 있다. 그리고 이것은 사용자가 미리 예상하지 못한 상태를 발생시킬 수 있는 코드 실행을 위한 경쟁 상태를 만드는 것이다. 재진입은 그러한 레이스 컨디션의 한 예다. 이번 절에서는 이더리움 블록체인에서 발생할 수 있는 다른 종류의 레이스 컨디션에 대해 설명한다.

### 취약점

대부분의 블록체인과 마찬가지로 이더리움 노드는 트랜잭션을 풀링하여 블록으로 만든다. 채굴자가 합의 메커니즘을 해결하면 트랜잭션은 유효한 것으로 간주한다. 블록을 생성하는 채굴자는 또한 어느 트랜잭션이 블록에 포함될 것인지 풀에서 가스 가격순으로 블록을 정렬하여 선택한다. 여기서 다음과 같은 잠재적인 공격 경로가 생길 수 있다. 공격자는 어떤 문제에 대한 해결책을 포함하는 트랜잭션에 대한 정보를 트랜잭션 풀에서 보고, 해답자의 권한을 수정 또는 취소하거나 트랜잭션상의 상태를 해답자에게 불리하게 바꿀 수 있다. 그런 다음, 공격자는 이 트랜잭션에서 데이터를 가져와서 자신의 트랜잭션을 생성하되, 원본보다 먼저 블록체인에 포함되도록 하기 위해 더 높은 가스 값을 설정할 수 있다.

간단한 예제로 이것이 어떻게 작동하는지 보자.

``` solidity
contract FindThisHash {
    bytes32 constant public hash = 0xb5b5bffweifenbb4bf4343526nfrgggfdsff;

    constructor() public payable {} // 이더 입금

    function solve(string solution) public {
        require(hash == sha3(solution));
        msg.sender.transfer(1000 ether);
    }
}
```

이 컨트랙트에 1,000개의 이더가 들어 있다고 가정해 보자.

SHA-3 해시의 프리이미지를 찾는 사용자는 그 솔루션을 제출하고 1,000개의 이더를 받아올 수 있다. 한 사용자가 솔루션이 Ethereum!이라는 것을 찾아냈다고 가정해 보자. 그들은 Ethereum!을 파라미터로 solve를 호출한다. 유감스럽게도 공격자는 모든 사람이 제출하는 솔루션을 트랜잭션 풀에서 볼 수 있을 정도로 영리하다. 그들은 이 솔루션을 보고 유효성을 확인한 다음, 가스 가격이 원래 트랜잭션보다 훨씬 높은 동일한 트랜잭션을 제출한다. 블록을 만드는 채굴자는 더 높은 가스 가격을 제시하는 공격자의 트랜잭션을 먼저 선택할 것이고, 원래 문제를 해결했던 사람의 트랜잭션보다 먼저 공격자의 트랜잭션을 처리할 것이다. 공격자는 1,000개의 이더를 가져가고 문제를 해결한 사용자는 아무것도 얻을 수 없다. 이러한 '프런트 러닝' 취약점의 경우, 채굴자는 공격 자체를 실행하기 위해 개별적인 인센티브를 받는 것에 유의하자. 공격자가 채굴자가 될 가능성을 과소평가해서는 안 된다.

## 예방 기법

이러한 종류의 프런트 러닝 공격을 수행할 수 있는 액터는 두 가지 클래스가 있다. 사용자와 채굴자다. 첫 번째 클래스에 취약한 컨트랙트는 두 번째 클래스에 취약한 컨트랙트보다 훨씬 나쁘다. 왜냐하면 특정 블록을 대상으로 하는 개별 채굴자와는 다르게, 채굴자는 오직 블록을 채굴할 때 공격을 수행할 수 있기 때문이다. 이러한 두 가지 클래스의 공격을 완화시킬 수 있는 몇 가지 방법을 알아보자.

한 가지 방법은 가스 가격에 상한을 두는 것이다. 이렇게 하면 사용자가 상한 범위 이상으로 gasPrice를 높여서 트랜잭션 우선순위를 갖는 것을 막을 수 있다. 이 방법은 첫 번째 클래스의 공격자만 막는다. 이 시나리오의 채굴자들은 가스 가격과 관계없이 원하는 대로 트랜잭션의 순서를 변경할 수 있기 때문에 컨트랙트를 계속 공격할 수 있다.

좀 더 강력한 방법은 커밋-공개 방식을 사용하는 것이다. 이러한 구조는 사용자가 숨겨진 정보를 사용하여 트랜잭션을 전송하도록 만든다. 트랜잭션이 블록에 포함된 후, 사용자는 전송된 데이터를 표시하는 트랜잭션을 전송한다. 이 방법은 채굴자와 사용자가 트랜잭션의 내용을 결정할 수 없기 때문에 프런트 러닝 트랜잭션을 방지한다. 그러나 이 방법은 트랜잭션 값을 숨길 수 없다. ENS 스마트 컨트랙트를 통해 사용자는 커밋된 데이터에 소비하고자 하는 이더의 양이 포함된 트랜잭션을 보낼 수 있다. 그런 후에 사용자는 임의의 값으로 트랜잭션을 보낼 수 있다. 공개 단계에서 사용자는 트랜잭션에서 보낸 금액과 지출하고자 하는 금액의 차이를 환불받는다.

로렌츠 브레이덴바흐, 필 다이안, 아리 주엘스, 플로리안 트라메르의 제안은 잠수함 송금을 사용하는 것이다. 이 아이디어를 효율적으로 구현하려면 CREATE2 연산코드가 필요하다. 이 연산코드는 현재 채택되지 않았지만, 향후 하드 포크에 포함될 것으로 보인다.

## 실제 사례 : ERC20과 뱅코어

ERC20 표준은 이더리움에서 토큰을 구축하기 위한 것으로 잘 알려져 있다. 이 표준은 approve 기능으로 인해 발생할 수 있는 잠재적인 프런트 러닝 취약점을 갖고 있다. 이 표준은 approve 함수를 다음과 같이 규정한다.

``` solidity
function approve(address _spender, uint256 _value) returns (bool success);
```

이 함수를 사용하면 어떤 한 사용자가 다른 사용자에게 자신을 대신하여 토큰을 전송하는 것을 허용한다. 예를 들어, 취약점은 사ㅛㅇ자 앨리스가 친구인 밥이 100 토큰을 사용하는 것을 승인하는 시나리오에서 발생한다. 앨리스는 나중에 100개의 토큰을 소비하라는 밥에 대한 승인을 철회하기로 결정하여 밥의 할당을 50개의 토큰으로 설정하는 트랜잭션을 만든다. 주의 깊게 체인을 지켜본 밥은 이 트랜잭션을 보고 100개의 토큰을 소비하는 트랜잭션을 작성한다. 그는 앨리스보다 더 높은 가스 가격을 쓴다. 그래서 밥의 트랜잭션은 앨리스의 트랜잭션보다 우선시된다. 어떤 approve의 구현은 앨리스가 트랜잭션을 커밋할 때 밥이 그의 100 토큰을 전송하는 것을 허용하고 밥의 승인을 50토큰으로 다시 설정하여 실제로 밥이 150개의 토큰에 접근할 수 있게 한다.

눈에 띄는 또 다른 실제 사례는 뱅코어다. 그의 팀은 초기 뱅코어 구현에서 수익성 있는 공격을 보여주었다. 그의 블로그 게시물과 데브콘3 토크는 어떻게 이것이 행해졌는지 더 자세하게 논의 했다. 본질적으로 토큰의 가격은 값을 근거로 결정된다. 사용자는 뱅코어 트랜잭션을 위한 트랜잭션 풀을 보고 가격 차이로부터 이익을 얻도록 프런트 러닝할 수 있다. 이 공격은 뱅코어 팀이 이미 해결했다.

## 서비스 거부 (DoS)

이 범주는 매우 광범위하지만, 기본적으로 사용자가 일정 기간 또는 일부의 경우 영구적으로 컨트랙트를 실행할 수 없게 만드는 공격으로 구성된다.

### 취약점

컨트랙트가 동작하지 않게 할 수 있는 방법은 다양하다. 여기서 우리는 DoS 취약점으로 이어질 수 있는 몇 가지 불확실한 솔리디티 코딩 패턴을 강조한다.

- 외부에서 조작된 매핑 또는 배열을 통한 루핑

    이 패턴은 아래의 컨트랙트 사례에서처럼 소유자가 토큰을 distribute 같은 함수로 투자자들에게 분배하기를 원할 때 전형적으로 나타난다.

    ``` solidity
    contract DistributeTokens {
        address public owner;
        address[] investors;
        uint[] investorTokens;

        function invest() public payable {
            investors.psh(msg.sender);
            investorTokens.push(msg.value * 5);
        }

        function distribute() public {
            require(msg.sender == owner)
            for (uint i = 0; i < investors.length; i++) {
                transferToken(investors[i], investorTokens[i]);
            }
        }
    }
    ```

    이 컨트랙트의 루프는 인위적으로 부풀려질 수 있는 배열을 실행한다는 것을 주목하라. 공격자는 많은 사용자 계정을 만들어 investor 배열을 크게 만들 수 있다. 원칙적으로 for 루프를 실행하는 데 요구되는 가스가 블록 가스 한도를 초과하도록 수행할 수 있기 때문에, 근본적으로 distribute 함수가 동작하지 않게 할 수 있다.

- 소유자 운영

    또 다른 공통적인 패턴은 소유자가 컨트랙트에서 특정 권한을 갖고 컨트랙트가 다음 상태로 진행하기 위해 몇 가지 작업을 수행해야 하는 경우다. 일례로, 이니셜 코인 오퍼링 컨트랙트 하나를 들 수 있는데, 이 컨트랙트는 토큰의 송금을 가능하게 하기 위해서 소유자가 컨트랙트를 finalize하도록 요구한다. 예를 들면, 다음과 같다.

    ``` solidity
    bool public isFinalized = false;
    address public owner;

    function finalize() public {
        require(msg.sender == owner);
        isFinalized == true;
    }

    function transfer(address _to, uint _value) returns (bool) {
        require(isFinalized);
        super.transfer(_to, _value);
    }
    ```

    이러한 경우, 권한이 있는 사용자가 개인키를 잃거나 비활성 상태가 되면 전체 토큰 컨트랙트가 작동하지 않는다. 이 경우 소유자가 finalize를 호출할 수 없을 때는 토큰을 전송할 수 없게 되어 전체 토큰 생태계의 운영이 단 하나의 주소에 의해 결정되게 된다.

- 외부 호출을 기반으로 한 진행 상태

    새로운 상태로 진행할 때 주소로 이더를 보내거나 외부 소스로부터 입력을 기다려야 하는 컨트랙트가 종종 작성된다. 이러한 패턴은 외부 호출이 실패하거나 외부적 요인으로 인해 차단된 경우 DoS 공격을 일으킬 수 있다. 이더를 보내야 되는 조건을 가진 예에서는 사용자가 이더의 수신을 허용하지 않는 컨트랙트를 만들 수 있다. 컨트랙트가 새로운 상태로 진행하기 위해 이더가 출금되기를 요구하면, 이 이더는 이더의 수신을 허용하지 않는 사용자의 컨트랙트 때문에 절대 전송될 수 없으므로 컨트랙트는 새로운 상태를 결코 달성하지 못할 것이다.

## 예방 기법

첫 번째 예에서 컨트랙트는 외부 사용자가 인위적으로 조작할 수 있는 데이터 구조를 통해 루프를 돌려서는 안 된다. 각 투자자가 독립적으로 토큰을 청구하기 위해 withdraw 함수를 호출하는 출금 패턴을 추천한다.

두 번째 예는 컨트랙트의 상태를 변경하기 위해 권한 있는 사용자가 필요한 경우였다. 그러한 예에서는 소유자가 무능화되는 경우에 대비한 안전장치가 사용될 수 있다. 한 가지 해결책은 소유자를 다중 컨트랙트로 만드는 것이고, 또 다른 해결책은 시간-잠금을 사용하는 것이다. 주어진 예에서 13행의 require는 require(msg.sender == owner || now > unlockTime)처럼 unlockTime에 의해 지정된 시간 이후에 사용자의 요청이 처리될 수 있는 시간 기반 메커니즘을 포함할 수 있다. 이러한 종류의 완화 기술은 세 번째 예에서도 사용할 수 있다. 만약 새로운 상태로 진행하기 위해 외부 호출이 필요한 경우 호출이 실패할 때 대처할 수 있어야 하고, 요구되는 호출이 결코 일어나지 않은 경우를 대비해 시간 기반의 자동적인 상태 진행이 되도록 하는 장치를 추가해 볼 수도 있다.

### 실제 사례 : GovernMental

GovernMental은 상당히 많은 양의 이더를 축적한 오래된 폰지 스킴이었는데, 유감스럽게도 이 절에서 언급한 DoS 취약점에 취약했다. 이더릭의 레딧 게시물은 컨트랙트에서 이더를 출금하기 위해서 어떻게 매우 큰 매핑을 삭제하도록 그 컨트랙트가 요구했는지를 설명한다. 당시에는 그 매핑을 삭제하는 데 들어가는 가스 비용이 블록가스 한도를 초과했기 때문에 1,100개의 이더를 출금할 수 없었다. 그 컨트랙트의 주소는 0xFEIJFIWEJFEW~~ 이고, 이후 트랜잭션 0x~~~에서 출금할 수 있었다. 이 트랜잭션에서 2.5M 가스를 사용하여 최종적으로 1,100개의 이더를 얻었다.

