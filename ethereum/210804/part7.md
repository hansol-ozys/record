## 스마트 컨트랙트란 무엇인가

스마트 컨트랙트란 용어는 다양한 것들을 설명하기 위해 수년 동안 사용되어 왔다. 1990년대 암호학자 닉 사보는 이 용어를 "당사자들이 다른 약속에 따라 수행하는 프로토콜을 포함하여 디지털 형식으로 지정된 일련의 약속"이라고 정의했다. 그 이후로 스마트 컨트랙트의 개념은, 특히 2009년 비트코인의 발명으로 탈중앙화 블록체인 플랫폼이 도입된 후에 진화했다. 이더리움의 컨텍스트에서 이더리움 스마트 컨트랙트는 스마트하지도 않고 법적 컨트랙트도 아니기 때문에 다소 잘못된 이름임에도 이미 확고하게 자리를 잡았다. 이 책에서는 '스마트 컨트랙트'라는 용어를 불변적인 컴퓨터 프로그램을 지칭하는데, 이 프로그램은 이더리움 네트워크 프로토콜의 일부인 이더리움 가상 머신의 컨텍스트상에서 결정론적으로 작동한다. 이제 스마트 컨트랙트의 정의를 살펴보자.

- 컴퓨터 프로그램

    스마트 컨트랙트는 단순히 컴퓨터 프로그램이다. '컨트랙트'라는 단어는 이런 맥락에서 법적인 의미는 없다.

- 불변의

    스마트 컨트랙트 코드는 일단 배포되면, 변경할 수 없다. 기존 소프트웨어와 달리 스마트 컨트랙트를 수정하는 유일한 방법은 새로운 인스턴스를 배포하는 것이다.

- 결정론적

    스마트 컨트랙트를 실행한 결과물은 그것을 실행한 모든 이에게 동일한데, 실행을 시작한 트랜잭션의 컨텍스트와 실행 시점에 이더리움 블록체인의 상태가 동일하다는 전제가 있기 때문이다.

- EVM 컨텍스트

    스마트 컨트랙트는 매우 제한적인 실행 컨텍스트에서 작동된다. 이들은 자신의 상태, 호출한 트랜잭션의 컨텍스트 및 가장 최근 블록의 일부 정보에 접근할 수 있다.

- 탈중앙화된 월드 컴퓨터

    EVM은 모든 이더리움 노드에서 로컬 인스턴스로 실행되지만, EVM의 모든 인스턴스는 동일한 초기 상태에서 작동하고 동일한 최종 상태를 생성하기 때문에 시스템 전체가 단일 '월드 커뮤터'로 작동한다.

## 스마트 컨트랙트의 생명주기

스마트 컨트랙트는 일반적으로 솔리디티 같은 고급 언어로 작성된다. 그러나 컨트랙트를 실행하려면 EVM에서 실행되는 저수준의 바이트코드로 컴파일되어야 한다. 일단 컴파일되면 고유한 컨트랙트 생성 트랜잭션을 사용하여 이더리움 플랫폼에 배포되며, 이 트랜잭션은 고유한 컨트랙트 생성 주소, 즉 0x0으로 전송된다. 각 컨트랙트는 이더리움 주소로 식별되며, 이 주소는 원래 계정 및 논스의 함수로 컨트랙트 생성 트랜잭션에서 파생된다. 컨트랙트의 이더리움 주소는 트랜잭션에서 수신자로 사용되거나 컨트랙트에 자금을 보내거나 컨트랙트 함수를 호출하는 데 사용할 수 있다. EOA와 달리 새 스마트 컨트랙트를 위해 생성한 계정과 관련된 키는 없다. 컨트랙트 작성자는 프로토콜 수준에서 특별한 권한을 얻지 못한다.

컨트랙트는 수정할 수 없음. 따라서 selfdestruct 기능으로 삭제해야 함.

## 이더리움 고급 언어의 소개

스마트 컨트랙트를 바이트코드로 직접 프로그래밍할 수는 있지만, EVM 바이트코드는 다루기가 까다로워서 프로그래머가 읽고 이해하기가 매우 어렵다. 대신, 대부분의 이더리움 개발자는 프로그램을 작성하는 데 고급 언어를 사용하고 바이트코드로 변환하는 컴파일러를 사용한다.

모든 고급 언어가 스마트 컨트랙트를 작성하는 데 적합할 수 있지만, EVM 바이트코드에 컴파일할 수 있도록 임의의 언어를 적용하는 것은 일반적으로 상당히 번거롭고 혼란스럽다. 스마트 컨트랙트는 고도로 제한된 최소 실행 환경에서 작동한다. 또한 EVM 관련 세부 시스템 변수 및 기능 세트를 사용할 수 있어야 한다. 따라서 스마트 컨트랙트를 작성하는 데 적합한 범용 언어를 만드는 것보다 스마트 컨트랙트 언어를 처음부터 만드는 것이 더 쉽다. 그 결과로 스마트 컨트랙트를 프로그래밍하기 위해 많은 특수 용도의 언어가 등장했다. 이더리움에는 EVM 실행 가능 바이트코드를 생성하는데 필요한 컴파일러와 함께 여러 언어가 있다.

## 솔리디티로 스마트 컨트랙트 생성

언어의 속성이 매우 일반적이어서 다른 여러 블록체인 플랫폼에서 스마트 컨트랙트를 코딩하는 데 사용된다. 솔리디티 프로젝트의 주된 제품은 솔리디티 언어로 작성된 프로그램을 EVM 바이트 코드로 변환하는 솔리디티 컴파일러 solc이다. 이 프로젝트는 또한 이더리움 스마트 컨트랙트를 위한 중요한 애플리케이션 바이너리 인터페이스 표준을 관리한다. 이에 대해서는 이 장에서 자세히 설명한다. 솔리디티 컴파일러의 각 버전은 솔리디티 언어의 특정 버전에 해당하며, 해당 버전의 솔리디티 언어를 컴파일한다.

## 솔리디티 학습

이하 '솔리디티 프로그래밍 에센셜' 책에서 학습한 내용들 소개.

유닛 멀티플라이어를 이용하면 컨트랙트의 가독성을 향상할 수 있음.

``` solidity
require(withdraw_amount <= 100000000000000000);
// =>
require(withdraw_amount <= 0.1 ether);
```

## 사전 정의된 글로벌 변수 및 함수

- msg.sender : 이 컨트랙트 호출을 시작한 주소.
- msg.value : 이 호출과 함께 전송된 이더의 값(웨이)
- msg.gas : 이 실행 환경의 가스 공급에 남은 가스의 양.
- msg.data : 이 호출의 데이터 페이로드
- msg.sig : 함수 선택자인 데이터 페이로드의 처음 4바이트.
- tx.gasprice : 트랜잭션을 호출하는 데 필요한 가스 가격
- tx.origin : 이 트랜잭션에 대한 원래 EOA의 주소
- block.blockhash : 블록 번호의 블록 해시. 더이상 사용 x
- block.coinbase : 현재 블록 수수료 및 보상의 수취인 주소.
- block.difficulty : 현재 블록의 난이도
- block.gaslimit : 현재 블록에 포함된 모든 트랜잭션에 소요될 수 있는 최대 가스양
- block.number : 현재 블록 넘버
- block.timestamp : 채굴자가 현재 블록에 넣은 타임스탬프
- address.balance : 웨이로 표현된 주소의 잔액.
- address.transfer(amount) : 이 주소로 금액을 전송.
- address.send(amount) : 위와 동일한 기능, but 예외 발생이 아닌 boolean 반환.
- address.call(payload) : 저수준 CALL함수.
- address.callcode(payload) : 위와 동일.
- address.delegatecall() : 위와 동일.

### 내장 함수

- addmod, mulmod : 모듈로 더하기 곱하기.
- keccak256, sha256, sha3, ripemd160 : 해시 알고리즘
- ecrecover : 서명에서 메시지 서명에 사용된 주소를 복구.
- selfdestrunct(recipient_address) : 현재 컨트랙트를 삭제하고 계정의 나머지 이더를 받는 사람 주소로 보냄.
- this : 현재 실행 중인 컨트랙트 계정의 주소

## 컨트랙트 정의

솔리디티의 주요 데이터 타입은 contract이다. Faucet 예제는 단순히 contract 객체를 정의한다. 객체 지향 언어의 객체와 마찬가지로, 컨트랙트는 데이터와 메소드가 포함된 컨테이너다.

솔리디티는 컨트랙트와 유사한 두 가지 객체 유형을 제공한다.

- interface : 인터페이스 정의는 함수가 정의되어 있지 않고 선언만 되어 있다는 것을 제외하면 컨트랙트와 완전히 같은 구조로 되어 있다. 이런 유형의 선언은 흔히 스텁이라고 불린다. 어떤 구현도 없이 함수의 인자와 반환 유형을 알려준다. 인터페이스는 컨트랙트의 형태를 지정한다. 상속될 때 인터페이스에 의해 선언된 각 함수는 자식에 의해 정의되어야 한다.

- library : 라이브러리 컨트랙트는 delegatecall 메서드를 사용하여 한 번만 배포되고 다른 컨트랙트에서 사용되기 위한 컨트랙트다.

## 함수

컨트랙트 내에서 EOA 트랜잭션이나 또 다른 컨트랙트에 의해 호출될 수 있는 함수를 정의한다. Faucet 예제에서는 withdraw와 fallback 함수의 두 가지 함수를 갖고 있다.

솔리디티에서 함수를 선언할 때 사용하는 구문은 다음과 같다.

``` solidity
function FunctionName([parameters]) {public|private|iternal|external}
[pure|constant|view|payable] [modifiers] [returns (return types)]
```

- FunctionName

    트랜잭션, 다른 컨트랙트 또는 동일한 컨트랙트 내에서 함수를 호출하는 데 사용되는 함수의 이름. 각 컨트랙트마다 한 개의 함수는 이름이 없이 정의될 수 있는데, 그것을 폴백 함수라고 부르고 다른 함수 이름이 없을 때 호출된다. 폴백 함수는 인수가 없으며 아무것도 반환할 수 없다.

- parameters

    이름 뒤에 함수 이름과 유형과 함께 전달되어야 하는 인수를 지정한다. Faucet 예제에서는 uint withdraw_amount를 withdraw 함수의 유일한 인수로 정의했다.

다음 키워드 세트는 함수의 가시성을 지정한다.

- public

    공개 함수는 기본값이다. 공개 함수는 다른 컨트랙트 또는 EOA 트랜잭션 또는 컨트랙트 내에서 호출할 수 있다. Faucet 예제에서 두 함수는 public으로 정의된다.

- external

    외부 함수는 명시적으로 키워드 this가 앞에 붙지 않는 한, 컨트랙트 내에서 호출할 수 없다는 점을 제외하면 공개 함수와 같다.

- internal

    내부 함수는 컨트랙트 내에서만 접근할 수 있다. 다른 컨트랙트 또는 EOA 트랜잭션으로는 호출할 수 없다. 파생된 컨트랙트에 의해서는 호출 될 수 있다.

- private

    비공개 함수는 내부 함수와 유사하지만 파생된 컨트랙트에서도 호출할 수 없다.

내부 및 프라이빗이라는 용어는 다소 오해의 소지가 있다는 점에 유의하자. 컨트랙트 내의 모든 함수 또는 데이터는 공개 블록체인에서 항상 볼 수 있다. 즉, 누구나 코드 또는 데이터를 볼 수 있다. 여기에 설명된 키워드는 함수를 호출할 수 있는 방법과 조건에만 영향을 준다.

두 번째 키워드 세트는 함수의 동작에 영향을 준다.

- constant 또는 view

    뷰로 표시된 함수는 상태를 변경하지 않는다. 상수라는 용어는 향후 릴리스에서 사용되지 않는 뷰의 별칭이다. 현재 컴파일러는 view 변경자를 강제화하지 않고 경고만 표시하지만, 솔리디티의 v0.5에서 강제 키워드가 될 것으로 예상된다.

- pure

    순수 함수는 스토리지에서 변수를 읽거나 쓰지 않는 함수다. 저장된 데이터를 참고하지 않고 인수에 대해서만 작동하고 데이터를 반환할 수 있다. 순수 함수는 부작용이나 상태가 없는 선언형 스타일의 프로그래밍을 지원하기 위한 것이다.

- payable

    payable이 선언되어 있다면 입금을 받을 수 있는 함수이고, 그렇지 않다면 입금이 거부될 것이다. EVM에서 설계할 때 두 가지 예외가 있는데, 보상 지불 및 SELFDESTRUCT다. 이 두 가지 경우는 코드의 실행이 지불의 일부는 아니기 때문에 폴백 함수가 payable로 선언되어 있지 않은 경우에도 지불될 것이다.

## 컨트랙트 생성자 및 selfdestruct

오직 한 번만 사용되는 특별한 함수가 있다. 컨트랙트가 생성될 때 생성자 함수가 있는 경우 이를 실행하여 컨트랙트의 상태를 초기화한다. 생성자는 컨트랙트 생성과 동일한 트랜잭션에서 실행된다. 생성자 함수는 반드시 선택할 필요가 없는 선택사항이다.

생성자는 두 가지 방법으로 지정할 수 있다. 솔리디티 v0.4.21까지 생성자는 아래에 보이는 것처럼 컨트랙트의 이름과 동일한 이름의 함수이다.

``` solidity
contract MEContract {
    function MEContract() {

    }
}
```

이 방식의 문제점은, 생성자 함수 이름은 변경되지 않은 상태에서 컨트랙트 이름만 변경될 때, 해당 함수가 더는 생성자 함수로 작동하지 않게 된다는 점이다. 마찬가지로 컨트랙트 또는 생성자의 이름에 실수로 오타가 있는 경우 더 이상 생성자로 작동하지 않게 된다. 이것은 예상하지 못한, 발견하기 어려운 꽤 심각한 버그의 원인이 될 수 있다. 예를 들어, 생성자가 제어 목적으로 컨트랙트의 소유자를 설정하는 경우를 상상해 보라. 만약 함수의 이름 오류로 인해 실제 생성자로 작동하지 않게 된다면, 소유자가 컨트랙트 생성 시 설정되지 않은 채 남아 있을 뿐만 아니라 함수는 정상적인 함수처럼 영구적이고 '호출 가능한' 컨트랙트의 일부로 배포된다. 이는 제 3자가 컨트랙트를 가로채서 컨트랙트 생성 후 '소유자'가 되는 것을 허용하는 꼴이 된다.

컨트랙트와 동일한 이름을 갖는 것에 기반한 생성자 함수의 잠재적 문제를 해결하기 위해 솔리디티 v0.4.22에서는 생성자 함수처럼 작동하지만, 이름이 없는 constructor 키워드를 도입했다. 컨트랙트의 이름을 변경해도 생성자에는 전혀 영향을 주지 않는다. 또한 어떤 함수가 생성자인지 쉽게 식별할 수 있다. 이 방식의 생성자 함수는 다음과 같은 모양이다.

``` solidity
pragma ^0.4.22;
contract MEContract {
    constructor () {
        // 생성자
    }
};
```

요약하면, 컨트랙트의 생명주기는 EOA 또는 컨트랙트 계정으로부터 트랜잭션 생성을 시작한다. 생성자가 있는 경우라면 컨트랙트 생성의 일부분으로 실행되어 컨트랙트가 생성될 때 컨트랙트 상태를 초기화한 다음 소멸한다.

또 다른 컨트랙트 생명주기의 끝은 컨트랙트 소멸이다. 컨트랙트는 SLEFDESTRUCT라는 특수한 EVM 연산코드에 의해 소멸된다. 예전에는 SUICIDE라고 불렀지만, 이 단어의 부정적인 의미 때문에 그 이름은 더는 사용되지 않는다. 솔리디티에서 이 연산코드를 selfdestruct라는 고수준의 내장 함수로 표시된다. 이 함수는 하나의 인수, 즉 컨트랙트 계정에 남아 있는 이더 잔액을 받기 위한 주소를 받는다. selfdestruct의 형태는 다음과 같다.

``` solidity
selfdestruct(address recipient);
```

여러분이 만약 삭제 가능한 컨트랙트 생성을 원한다면 컨트랙트에 명시적으로 추가해야 한다. 이것은 컨트랙트를 삭제할 수 있는 유일한 방법이고, 기본 옵션으로 자동으로 포함되지 않는다. 이런 면에서 보자면, 어떤 컨트랙트가 영원히 지속된다는 것을 보장해야 될 때는 SELFDESTRUCT 연산코드를 포함하지 않으면 된다.

## FAUCET에 생성자와 selfdestruct를 추가하는 예제

이하 실습.

``` solidity
function destroy() public {
    require(msg.sender == owner);
    selfdestruct(owner);
}
```

## 함수 변경자

솔리디티는 함수 변경자라 불리는 특별한 유형의 함수를 제공한다. 함수 선언에 modifier라는 이름을 추가하여 함수에 변경자를 적용한다. 변경자는 컨트랙트 내에서 함수에 적용되어야 할 여러 조건을 생성하기 위해 가장 자주 사용된다. 우리는 destroy 함수내에 접근 제어 구문을 이미 갖고 있다. 이 조건을 표현하는 함수 변경자를 만들어보자.

``` solidity
modifier onlyOwner {
    require(msg.sender == owner);
    _;
}
```

이 함수 변경자는 이름이 onlyOwner이고 이를 적용하는 모든 함수에 다음의 조건을 설정한다. 컨트랙트의 owner로 저장된 주소가 트랜잭션의 msg.sender 주소와 동일해야 한다. 이것은 접근 제어를 위한 기본 디자인 패턴으로, 오직 컨트랙트 소유자만 onlyOwner 변경자를 가진 모든 함수를 실행할 수 있게 해준다.