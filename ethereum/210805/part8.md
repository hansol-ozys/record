# 스마트 컨트랙트와 바이퍼

바이퍼는 이더리움 가상 머신을 위한 실험적인 컨트랙트용 프로그래밍 언어인데, 개발자들이 이해하기 쉬운 코드를 작성할 수 있도록 함으로써 뛰어난 감사 용이성을 제공하고자 만들어졌다. 사실, 바이퍼의 주요 원칙 중 하나는 개발자들이 오독하기 쉬운 코드를 작성할 수 없게 하자는 것이다.

이 장에서는 스마트 컨트랙트의 공통적인 문제를 살펴보고, 바이퍼 컨트랙트 프로그래밍어를 소개한 후에 솔리디티와 비교하여 그 차이점을 보여주려고 한다.

## 취약점과 바이퍼

최근의 한 연구에서는 배포된 약 백만 개의 이더리움 스마트 컨트랙트를 분석한 결과, 심각한 취약점을 가진 스마트 컨트랙트가 아주 많다는 사실을 확인했다. 분석을 통해 연구자들은 취약점을 세 가지 유형으로 요약했다.

- 자기파괴 컨트랙트 : 아무 주소를 이용해서 삭제시킬 수 있는 스마트 컨트랙트
- 탐욕 컨트랙트 : 이더를 뺴올 수 없도록 막아버리는 상태에 도달할 수 있는 컨트랙트
- 방탕한 컨트랙트 : 이더를 아무런 주소로 보낼 수 있게 만든 스마트 컨트랙트

이러한 취약성들은 코드를 통해 스마트 컨트랙트에 심어지게 된다. 이와 같은 취약점들을 의도적으로 삽입한 것은 아니라고 주장할지는 모르지만, 잘못된 스마트 컨트랙트 코드는 이더리움 사용자에게 예상치 못한 자금 손실을 초래할 수 있어서 바람직하지 않다. 바이퍼는 안전한 코드를 작성하기 쉽게 해주는데, 다른 말로 하면 오독을 하기 쉽거나 취약점이 있는 코드를 작성하기 어렵게 한다.

## 솔리디티와 비교

바이퍼가 안전하지 않은 코드 작성을 방지하는 방법 중 하나는 의도적으로 솔리디티의 기능 중 일부를 생략하는 것이다. 바이퍼로 스마트 컨트랙트를 개발하고자 한다면, 바이퍼에서 어떤 기능들이 왜 생략되었는지를 이해하는 것이 중요하다. 따라서 이 절에서는 이 생략된 기능들을 살펴보고, 생략하게 된 타당한 이유를 설명한다.

### 변경자

이전 장에서 살펴봤듯이, 솔리디티에서는 변경자를 사용하여 함수를 작성할 수 있다. 예를들어, 다음 changeOwner라는 함수는 실행의 일부로 onlyBy라는 변경자에서 코드를 실행한다.

``` solidity
function changeOwner(address _newOwner) public onlyBy(owner) {
    owner = _newOwner;
}
```

이 변경자는 소유권과 관련된 규칙을 적용한다. 보다시피, 이 특정 변경자는 changeOwner 함수를 대신하여 사전 검사를 수행하는 메커니즘 기능을 한다.

``` solidity
modifier onlyBy(address )