# 이더리움 기초

## 이더 화폐 단위

이더 : ETH
웨이 : wei (1ETH = 1000000000000000000(10 ** 18)wei)


## 통제와 책임

이더리움 같은 개방형 블록체인은 탈중앙화된 시스템으로 작동하기 때문에 중요하다. 이것이 뜻하는 바는 많지만, 한 가지 중요한 측면은 이더리움의 각 사용자가 자금 및 스마트 컨트랙트에 대한 접근을 제어하는 자체 개인키를 관리하고 제어할 수 있어야 한다는 것이다. 자금 및 스마트 컨트랙트에 대한 접근 조항을 계정 또는 지갑이라고도 한다. 기본 원칙은 하나의 개인키가 하나의 '계정'과 동일한 것이라고 생각하면 쉽다. 일부 사용자는 온라인 거래소 같은 제3자 관리인을 이용하고 직접 개인키를 관리하지 않으려 한다. 이 책에서는 개인키를 제어하고 관리하는 방법을 알려줄 것이다.

통제에는 큰 책임이 따른다. 개인키를 분실하면 자금 및 컨트랙트에 대한 접근 권한을 잃게 된다. 어느 누구도 접근 권한을 회복하도록 도와줄 수 없으며, 자금은 영원히 잡겨있을 것이다. 다음은 이 책임을 관리하는 데 도움이 되는 몇 가지 팁이다.

- 보안을 즉흥적으로 처리하지 마라. 검증된 표준 접근 방식을 사용하라.
- 계정이 더 중요할수록 더 높은 보안 조치가 취해져야 한다.
- 에어 갭이 있는 장치를 사용하면 최고 수준의 보안이 유지되지만, 이 수준이 모든 계정에 필요하지는 않다.
- 개인키를 플레인 혀태로 저장 x.
- 개인키는 디지털 '키저장소'파일로 저장할 수 있다.

## 외부 소유 계정 및 컨트랙트

메타마스크 지갑에서 생성한 계저의 유형을 외부 소유 계정 이라고 한다. 외부 소유 계정 = 개인키가 있는 계정. 또 다른 유형의 계정은 컨트랙트 계정 이다. 컨트랙트 계정은 단순 EOA계정이 가질 수 없는 스마트 컨트랙트 코드가 있다. 또한 컨트랙트 계정에는 개인키가 없다.

컨트랙트에는 EOA와 마찬가지로 주소가 있으며, 이더를 보내고 받을 수 있다. 그러나 트랜잭션 목적지가 컨트랙트 주소일 때 트랜잭션과 트랜잭션 데이터를 입력으로 사용하여 컨트랙트가 EVM에서 실행된다. 이더 외에도 트랜잭션에는 실행할 컨트랙트의 특정 함수와 해당 함수에 전달할 파라미터를 나타내는 데이터가 포함될 수 있다. 이렇게 해서 트랜잭션은 컨트랙트 내의 함수를 호출할 수 있다.

EOA만 트랜잭션을 시작할 수 있음.

## 간단한 컨트랙트 : 테스트 이더 Faucet

Faucet 코드

``` solidity
contract Faucet {
    function withdraw(uint withdraw_amount) public {
        require(withdraw_amount <= 1000000000000000000);
        msg.sender.transfer(withdraw_amount);
    }

    function () public payable {}
}
```

``` solidity
function () public payable {}
```

이 함수는 폴백 또는 기본 함수로, 컨트랙트를 실행한 트랜잭션이 컨트랙트에 선언된 함수 또는 어떠한 함수도 지정하지 않았거나 데이터를 포함하지 않은 경우에 호출된다. 컨트랙트에는 하나의 기본 함수를 가질 수 있으며, 일반적으로 이더를 받는 함수다. 이런 이유로 기본 함수는 public이고 payable 함수로 정의되며, 이는 이더를 컨트랙트에 받아들일 수 있음을 의미한다. 중괄호 안의 비어 있는 정의가 나타내듯이, 이더를 받는 일 외에는 아무것도 하지 않는다. 이더를 지갑 같은 컨트랙트 주소로 보내는 트랜잭션을 발생시키면 이 함수가 처리한다.

## Faucet 컨트랙트 컴파일

리믹스로 실습함.

## 블록체인에 컨트랙트 생성하기

리믹스로 실습함.
그런데, 컨트랙트를 배포할 때마다 storage가 커질 것이고, 시간이 지날수록 성능은 느려지지 않을까??

## 컨트랙트 사용하기

컨트랙트는 블록체인에 바이트코드를 등록하는 특별한 트랜잭션에 의해 생성된다. 컨트랙트가 블록체인에서 생성되면 지갑과 마찬가지로 이더리움 주소를 갖게 된다. 누군가가 컨트랙트 주소로 트랜잭션을 보낼 때마다 그 트랜잭션을 입력값으로 하여 컨트랙트가 EVM에서 실행된다. 컨트랙트 주소로 보내지는 트랜잭션에는 이더, 데이터 또는 둘 다를 포함할 수 있다. 트랜잭션이 이더를 포함하면, 이는 컨트랙트 잔액에 '예치된다'. 데이터가 포함되어 있으면 데이터에서는 컨트랙트에서 명명된 함수를 지정하고 호출하여 함수에 인수를 전달할 수 있다.

## 블록 탐색기에서 컨트랙트 주소 보기

리믹스 실습.

## 컨트랙트 자금 조달

현재 컨트랙트 상에는 생성 트랜잭션 하나만 기록되어 있다. 보다시피 컨트랙트에는 이더도 없다. 왜냐하면 컨트랙트 생성 트랜잭션을 보낼 때 이더를 전혀 보내지 않았기 때문인데, 보내려고 했으면 같이 보낼 수 있기는 했었다.

``` solidity
function () public payable {}
```

이 함수로 인해 컨트랙트 계정 잔액애 입금할 수 있다.

## 컨트랙트 출금

리믹스 실습
