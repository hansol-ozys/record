# 지갑

이더리움에서는 '지갑'이라는 단어를 몇 가지 다른 것을 설명하는 데 사용한다.

넓은 의미에서 지갑은 이더리움의 주요 사용자 인터페이스를 제공하는 소프트웨어 애플리케이션이다. 지갑은 사용자 돈에 대한 접근을 통제하고, 키와 주소를 관리하며, 잔액을 추적하고, 트랜잭션 생성과 서명을 제어한다. 여기에 더해서 몇몇 이더리움 지갑은 ERC20 토큰처럼 컨트랙트와 상호작용할 수 있다.

개발자의 시각으로 좀 더 좁혀보면, 지갑이란 단어는 사용자의 키를 보관하고 관리하기 위해 사용되는 시스템을 의미하며, 모든 지갑은 키 관리 구성요소를 갖고 있다. 그 자체로 전부인 지갑도 있고, 좀 더 넓은 범주에서 이더리움 기반 탈중앙화 애플리케이션의 인터페이스인 브라우저의 일부이거나, 12장에서 더 상세하게 다룰 댑의 한 부분인 지갑도 있다.

이번 장에서는 개인키를 담는 공간이자 키를 관리하는 시스템으로서 지갑을 살펴볼 것이다.

## 지갑 기술의 개요

이번 절에서는 사용자 친화적이고, 안전하며 유연한 이더리움 지갑을 구축하는 데 사용하는 다양한 기술을 정리한다.

지갑을 설계할 때 중요한 고려사항 하나는 편의성과 프라이버시 사이에 균형을 맞추는 것이다. 가장 편리한 이더리움 지갑은 하나의 개인키와 주소를 가지고 이를 재사용해서 모든 것을 처리하는 지갑이다. 하지만 불행하게도 그러한 솔루션은 누구나 쉽게 여러분의 모든 트랜잭션을 추적하고 연결하여 볼 수 있으므로 프라이버시에 대한 악몽이 될 수 있다. 모든 트랜잭션에 새로운 키를 사용하는 것이 프라이버시를 위해 가장 좋지만 관리하기가 몹시 어렵다.  그 사이에서 적절한 균형을 달성하기가 쉽지 않은데, 이것이 바로 좋은 지갑을 설계하는 것이 다른 무엇보다 중요한 이유다.

이더리움에 관한 일반적인 오해 중 하나는 이더리움 지갑이 이더 혹은 토큰을 보유한다는 것이다. 사실 매우 엄격하게 말하자면 지갑은 단지 키만 보유한다. 이더 혹은 다른 토큰은 이더리움 블록체인에 기록된다. 사용자는 지갑에 있는 키로 트랜잭션을 서명함으로써 네트워크에서 토큰을 제어한다. 이러한 맥락에서 이더리움 지갑은 키체인이다. 지갑에 있는 키가 이더나 토큰을 전송하는 데 필요한 유일한 것이라고 생각하면, 실제로 이렇게 구분하는 것이 큰 의미는 없다. 중요한 것은 기존 은행의 중앙화된 시스템을 다루는 것에서부터 블록체인 플랫폼의 탈중앙화된 시스템으로 사고방식을 바꾸는 것이다. 실제로 이것은 지갑 없이도 계좌의 잔액을 확인하는 독립적인 방법이 있음을 의미한다. 더구나, 사용하던 지갑 앱이 싫어지면 현재 지갑에서 다른 지갑으로 계정을 옮길 수 있다.

지갑은 주요한 두 가지 형태가 있는데, 지갑이 포함하는 키가 서로 관련이 있느냐 없느냐에 따라 구분된다.

첫 번째 유형은 각기 다른 무작위 수로부터 각각의 키를 무작위적으로 추출하는 비결정적 지갑이다. 이러한 형태의 지갑을 '그냥 열쇠뭉치'라는 뜻의 JBOK 지갑이라 부른다.

두 번째 유형은 모든 키가 시드라고 하는 단일 마스터 키로부터 파생된 결정적 지갑이다. 이러한 지갑 형태의 모든 키는 서로 관련이 있고 원래의 시드를 갖고 있다면 다시 키를 파생시킬 수 있다. 결정적 지갑에는 여러 가지 키 파생 방식이 있는데, 가장 많이 사용하는 파생 방식은 HD지갑에서 설명하는 트리 같은 구조를 사용한다.

휴대전화를 도난당하거나 화장실에 떨어뜨림으로써 데이터를 분실할 수 있다. 따라서 좀 더 안전한 결정적 지갑을 만들기 위해서 시드는 단어 목록으로 인코딩되어 불의의 사고에 대비할 수 있도록 적어두고 사용한다. 이를 지갑의 니모닉 코드 단어라고 한다. 물론 누군가가 여러분의 니모닉 코드 단어를 손에 넣으면 지갑을 재생성하여 여러분의 이더와 스마트 컨트랙트에 접근할 수 있다. 그러므로 복구 단어 목록은 아주 조심스럽게 다루고 절대로 컴퓨터나 휴대전화의 전자파일로 저장하지 말고 종이에 적어서 안전한 곳에 보관하기 바란다.

### 비결정적 지갑

첫 번째 이더리움 지갑은 각 지갑 파일에 무작위로 추출된 단일 개인키를 저장했다. 이런 '이전 스타일' 지갑은 여러 측면에서 불편하기 때문에 결정적 지갑으로 대체되고 있다. 예를 들어, 이더리움을 사용하는 동안 프라이버시를 극대화한다는 차원에서는 이더리움 주소의 재사용을 피하는 것이 좋은 지침으로 간주된다.

### 결정적 지갑

체인처럼 시드가 2번째, 3번째, ...의 개인 키를 알 수 있게 해준다.

### HD 지갑

HD 지갑은 결정적 지갑에 비해 몇가지 장점을 지닌다. 먼저, 트리 구조는 예를 들어 하위 키의 특정분기는 입금을 받는 데 사용하고 다른 분기는 송금 후 잔액을 받는데 사용할 수 있으며, 또한 부서, 자회사, 특정 기능 혹은 회계 범주로 다른 분기를 할당하여 기업 환경 설정과 같은 구조적인 의미를 표현하는 데도 사용할 수 있다.

HD 지갑의 두 번째 장점은 개인키에 접속하지 않고 사용자가 공개키 시퀀스를 만들 수 있다는 것이다. HD 지갑은 보안상 안전하지 않은 서버, 보기 전용, 수신 전용의 용도로 사용할 수 있는데, 이 때 이 지갑에는 자금을 움직이는 개인키가 들어있지 않게 만들 수 있다.


## 지갑의 모범 사례

- BIP-39 기반 니모닉 코드 단어
- BIP-32 기반 HD 지갑
- BIP-43 기반 다목적 HD 지갑 구조
- BIP-44 기반 복수화폐 및 복수계정 지갑

## 니모닉 코드 단어(BIP-39)

BIP-39는 니모닉 코드와 시드의 생성을 정의하는데, 여기서는 아홉 단계로 설명한다. 명확하게 하기 위해 프로세스를 두 부분으로 나누는데, 1~6단계는 97페이지의 '니모닉 단어 생성'절에서 보여주고, 7~9단계는 98페이지의 '니모닉에서 시드까지' 절에서 보여준다.

## 니모닉 단어 생성

1. 128~256 비트의 무작위 암호화 시퀀스 S를 생성.
2. S를 SHA-256으로 해싱한 값을 32비트로 나눈 처음 길이를 체크섬으로 생성한다.
3. 무작위 시퀀스 S의 끝에 체크섬을 추가한다.
4. 시퀀스와 체크섬을 연결한 것을 11비트 단위로 나눈다.
5. 각각의 11비트 값을 사전에 정의된 2,048단어 사전과 매핑한다.
6. 단어의 시퀀스로부터 순서를 유지하면서 니모닉 코드를 생성한다.

7. PBKDF2 키 스트레칭 함수의 첫번째 파라미터는 6단계에서 생성된 니모닉이다.
8. PBKDF2 키 스트레칭 함수의 두 번째 파라미터는 솔트다. 솔트는 문자열 상수 'mnemonic'과 선택적으로 사용자가 지정한 암호문을 연결하여 구성한다.
9. PBKDF2는 최종 출력으로 512비트 값을 만드는 HMAC-SHA512 알고리즘으로, 2048 해시 라운드를 사용하여 니모닉과 솔트 파라미터를 확장하며, 이 결과로 나온 512 비트 값이 시드다.

## HD 지갑(BIP-32)과 경로(BIP-43/44)

대부분의 HD 지갑은 결정적 키 생성을 위한 산업계의 사실상 표준인 BIP-32 표준을 따른다.
다음 절에서 설명하는 확장 키와 강화 키의 아이디어를 이해하는 것이 중요하다.

BIP-32 호환 가능 지갑과 동일한 키 파생 구현을 공유한다. 이더리움을 위해 설계된 지갑을 사용하거나 이더리움 주소 인코딩 라이브러리를 추가하여 비트코인에서 채택한 것을 사용하라.

### 확장된 공개키와 개인키

BIP-32의 용어로 말하자면, 키는 확장될 수 있다. 적절한 수학적 연산을 사용하여 확장된 '부모' 키는 '자식' 키를 파생시킬 수 있게 되고, 앞서 설명한 키와 주소의 계층 구조를 만들 수 있게 된다. 맨 앞에 있을 필요는 없으며, 트리 계층 구조의 어느 곳에서든 부모 키를 선택할 수 있다. 키를 확장하는 것은 키 자체를 가져와서 특수 체인 코드를 추가하는 것이다. 체인 코드는 자식 키를 생성하기 위해 각 키와 혼합된 256비트 이진 문자열이다.

# 그 뒤.

다 읽어보니, 아무튼 이 장은 지갑이 개인키를 어떻게 관리하는지에 대한 이론적 설명이 담겨있다. 한번 보는 건 좋지만, 굳이 외울 필요는 없어보임.